"""Module extensions for tools_codex (bzlmod)."""

load("//codex/private:repo.bzl", "codex_toolchains")

_OS_TO_CONSTRAINT = {
    "darwin": "@platforms//os:macos",
    "linux": "@platforms//os:linux",
    "windows": "@platforms//os:windows",
}

_ARCH_TO_CONSTRAINT = {
    "amd64": "@platforms//cpu:x86_64",
    "arm64": "@platforms//cpu:aarch64",
}

_PLATFORMS = [
    "darwin_arm64",
    "darwin_amd64",
    "linux_arm64",
    "linux_amd64",
    "windows_arm64",
    "windows_amd64",
]

_TOOLCHAIN_BUILD_HEADER = """# Generated by tools_codex

load("@tools_codex//codex/private:toolchain.bzl", "codex_toolchain")

package(default_visibility = ["//visibility:public"])
"""

_TOOLCHAIN_BUILD_TEMPLATE = """
codex_toolchain(
    name = "{platform}_impl",
    codex = "@codex_{platform}//:codex",
)

toolchain(
    name = "{platform}",
    exec_compatible_with = [
        {exec_constraints},
    ],
    toolchain = ":{platform}_impl",
    toolchain_type = "@tools_codex//codex:toolchain_type",
)

toolchain(
    name = "{platform}_runtime",
    target_compatible_with = [
        {exec_constraints},
    ],
    toolchain = ":{platform}_impl",
    toolchain_type = "@tools_codex//codex:runtime_toolchain_type",
)
"""

def _codex_toolchains_repo_impl(repository_ctx):
    """Creates a repository with toolchain definitions for all platforms."""
    lines = [_TOOLCHAIN_BUILD_HEADER]

    for platform in _PLATFORMS:
        os_name, arch = platform.split("_")
        exec_constraints = [
            _OS_TO_CONSTRAINT[os_name],
            _ARCH_TO_CONSTRAINT[arch],
        ]
        exec_constraints_str = ",\n        ".join(['"{}"'.format(c) for c in exec_constraints])

        lines.append(_TOOLCHAIN_BUILD_TEMPLATE.format(
            platform = platform,
            exec_constraints = exec_constraints_str,
        ))

    repository_ctx.file("BUILD.bazel", content = "\n".join(lines))

_codex_toolchains_repo = repository_rule(
    implementation = _codex_toolchains_repo_impl,
)

def _find_modules(module_ctx):
    """Find the root module and tools_codex module.

    Toolchain configuration is only allowed in the root module, or in
    tools_codex.
    See https://github.com/bazelbuild/bazel/discussions/22024 for discussion.
    """
    root = None
    tools_codex = None
    for mod in module_ctx.modules:
        if mod.is_root:
            root = mod
        if mod.name == "tools_codex":
            tools_codex = mod
    if root == None:
        root = tools_codex
    if tools_codex == None:
        fail("Unable to find tools_codex module")
    return root, tools_codex

def _codex_impl(module_ctx):
    """Implementation of the codex module extension."""
    root, tools_codex = _find_modules(module_ctx)

    downloads = root.tags.download or tools_codex.tags.download
    download = downloads[0] if downloads else None
    version = download.version if download else ""
    sha256 = download.sha256 if download else {}
    use_latest = download.use_latest if download else False

    # Download the Codex CLI binary for each platform
    for platform in _PLATFORMS:
        codex_toolchains(
            name = "codex_" + platform,
            version = version,
            platform = platform,
            sha256 = sha256.get(platform, ""),
            use_latest = use_latest,
        )

    # Create the toolchains repository
    _codex_toolchains_repo(name = "codex_toolchains")

_download = tag_class(
    attrs = {
        "version": attr.string(
            doc = "Version to download (e.g., 'rust-v0.92.0'). If empty, uses default version.",
        ),
        "sha256": attr.string_dict(
            doc = "SHA256 hashes per platform (e.g., {'darwin_arm64': 'abc...', 'linux_amd64': 'def...'}).",
        ),
        "use_latest": attr.bool(
            default = False,
            doc = "If true, fetches the latest version from GitHub releases instead of the default.",
        ),
    },
)

codex = module_extension(
    implementation = _codex_impl,
    tag_classes = {
        "download": _download,
    },
)
